h1. DataSet Manipulation

h2. Basic functionality

<hr>
You don't always have to get your DataSets from a database or a csv file. 
You can make your own from scratch:

<pre><code>
  ghost = Ruport::DataSet.new(%w[nickname, color])
</code></pre>

And then add some data:

<pre><code>
  ghost << ["blinky", "red"]
</code></pre>

You can make a copy of a DataSet using the <code>clone</code> method. There's
also an <code>empty_clone</code> method which gives you a DataSet with the 
same fields as the one you're copying, but with no data.

The <code> << </code> method tries to do the Right Thing depending on what you
are trying to add to your DataSet. You saw above that you can use an array. A 
hash also works:

<pre><code>
  ghost << {:color => "pink", :nickname => "pinky"}
</code></pre>

Or a DataRow:
<pre><code>
  inky = DataRow.new(%w[nickname, color], :data => %w[inky blue] )
  ghost << inky
</code></pre>

Or even another DataSet:
<pre><code>
  lesser_known = ghost.empty_clone 
  lesser_known << %w[funky green]
  lesser_known << %w[spunky gray]
  ghost << lesser_known
</code></pre>

DataSets are similar to arrays, and have many of the same methods. 
<code>length</code>,<code>[]</code>, <code>empty?</code>, 
<code>delete_at</code>, <code>first</code>, <code>last</code>, 
<code>pop</code>, <code>each</code>, <code>reverse_each</code>, 
<code>at</code>, and <code>clear</code> all work just like their counterparts
in Array.

h2. Set-like Operations

<hr>

Using the set operations in DataSet, you can manipulate sets of similar data 
to get what you're looking for. These methods only work if the DataSets have 
the same fields, which you can check with <code>same_shape?</code>. Keep in 
mind that these methods ignore duplicate rows, so each record in the result
set is unique.

We'll use these two DataSets that we've already gotten from a query on our 
database of great characters in literature:

<pre><code>
pacman:
  inky, blue
  blinky, red
  pinky, pink
  clyde, orange

ms_pacman:
  inky, blue
  blinky, red
  pinky, pink
  sue, orange
</code></pre>

To find the rows that two DataSets have in common, you can use the set 
intersection method, <code> & </code>:

<pre><code>
  common_ghosts = pacman & ms_pacman
</code></pre>

This will give you a new DataSet, <code>common_ghosts</code>, which consists 
of each row that appears in both of our original sets:

<pre><code>
  inky, blue
  blinky, red
  pinky, pink
</code></pre>

If you want the rows that are in either of two DataSets, use the set union 
method, <code> | </code>:

<pre><code>
  all_ghosts = pacman | ms_pacman
</code></pre>

Which gives us:
<pre><code>
  inky, blue
  blinky, red
  pinky, pink
  clyde, orange
  sue, orange
</code></pre>

Finally, we can take the difference of two sets with, you guessed it, the set
difference method, <code> - </code>. This method takes the first set and 
deletes from it each of the rows in the second set. For example:

<pre><code>
  pacman_only = pacman - ms_pacman
</code></pre>

giving us:
<pre><code>
  clyde, orange
</code></pre>

A lot of the times, these manipulations will be exactly what you need to get
your data organized in a reportable form.  However, there are situations where
you need something a little less structured, and the next section covers exactly
that.

h2. Using Tags

<hr>

Sometimes, you might want mark a row with some sort of flag to be used later on
down the line.  One of the key goals of Ruport is to allow you to use the same
data to produce a number of different reports.

One tool to help you do this is row based tagging.  Let's say for instance you
had a bunch of data that included phone numbers.  If you wanted to mark all the
ones that were missing an entry in that column, you might do something like
this:

<pre><code>
  my_data.each { |r| r.tag_as :missing_number if r["phone"].to_s.empty? }
</pre></code>


Note that this didn't do anything to actually change your data.  It also doesn't
tie any logic to the tags, it simply applies them if the condition is met.

That means that you or someone else who knows that the :missing_number tag has
been applied to the data doesn't need to know at all the criteria of the
labeling nor the actual structure of the data.  All they need to do is search
for the tag:

<pre><code>
  my_data.select { |r| r.has_tag? :missing_number }
</pre></code>

This sort of abstraction is useful when you may have several data sources with
different conditions that determine how they will be tagged.

h2. Calculated fields

<hr>

There are two types of calculated fields to consider when using DataSets:

# Something that is only going to be calculated once or when it's explicitly
told to be calculated.
# Something that is going to be calculated every time it is rendered.

Unfortunately there is no inbuilt support for calculated fields just yet, so you
need to roll your own.  I've written a recipe for each case which shows how I
handle this kind of thing.

h3. Static Calculated Fields

When dealing with fields you want to have stick around for a while,
the easiest thing to do is just create a new column to hold your calculations.

<pre><code>

  my_data.add_columns! "new_col"

</code></pre>

You could then just fill in this column with whatever calculated data you
wanted.  Below I set the new_col column to be equal to the first column's value
+ 1 for each row:

<pre><code>
  
  my_data.each { |r| r["new_col"] = r[0] + 1 }

</code></pre>

This approach is good for calculations you're only going to do when the DataSet
is populated or explicitly told to update.  

h3. Calculated Fields "On the fly"

Sometimes, you're going to need to generate some fields in a table every time it
is rendered as formatted output.  It's going to be a common task to rewrite
certain fields on the fly, so there is a convenience method for it in the table
rendering engine.  

Let's assume that we've got the same goal as before, to add an additional column
to the DataSet and then do a quick calculation on it.

The code below does more or less the same thing as before, but at format time
instead of DataSet building time.  It will not modify your original object.

<pre><code>
my_data.as(:html) do |eng|
  engine.data.add_columns! "new_col"
  engine.rewrite_column("new_col") { |row| row[0] + 1 }
end
</pre></code>

As you can probably guess, <tt>rewrite_column</tt> passes in the rows one at a
time and then reassigns the column you specify's cell to the return value of the
block.

Even though this process should probably be more tightly integrated, it's
certainly doable by the procedures above.

